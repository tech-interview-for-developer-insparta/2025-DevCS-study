# CS 스터디 2025-09-22 시작주차

## 1. JVM 구조 & GC

### JVM이란?
<img width="549" height="507" alt="img" src="https://github.com/user-attachments/assets/79eb9cbd-853e-4aa6-a8d7-286518185666" />

* **Java Virtual Machine**: 자바 프로그램이 운영체제에 종속되지 않고 실행될 수 있게 해주는 가상 머신.
* "한 번 작성하면 어디서든 실행된다(Write Once, Run Anywhere)"를 가능하게 하는 핵심 기술.

### JVM의 구조

1. **Class Loader (클래스 로더)**

   * `.class` 파일을 읽고 JVM 메모리로 적재.
   * 로딩 → 링크(검증/준비/해석) → 초기화 단계로 진행.
2. **Runtime Data Area (실행 데이터 영역)**

   * 프로그램 실행 시 사용되는 메모리 공간.
   * 구성 요소:

     * **Method Area**: 클래스 정보(메타데이터), static 변수, 상수 풀.
     * **Heap**: 객체 인스턴스 저장. GC가 관리하는 영역.
     * **Stack**: 메서드 호출 시 지역 변수, 매개변수 저장.
     * **PC Register**: 현재 실행 중인 명령어 주소.
     * **Native Method Stack**: JNI 같은 네이티브 코드 실행용.
3. **Execution Engine (실행 엔진)**

   * 바이트코드를 기계어로 변환 후 실행.
   * JIT(Just-In-Time) 컴파일러가 성능 최적화에 핵심 역할.
4. **Native Interface & Libraries**

   * C/C++ 같은 네이티브 코드와 연결.

### Garbage Collection (GC)

* **Heap 영역**에 있는 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제.
* 개발자가 직접 `free()` 호출할 필요 없음 → 메모리 안전성 향상.
* 알고리즘:

  * **Stop-The-World**: GC 수행 시 애플리케이션 멈춤.
  * **Mark & Sweep**: 사용 중인 객체 표시 → 미사용 객체 정리.
  * **Generational GC**: Young / Old 영역 나눠 관리 → 효율성 향상.
<img width="1609" height="698" alt="img (1)" src="https://github.com/user-attachments/assets/f8ef4057-4da7-48f2-8610-e9a7010bdead" />



```
Garbage Collection (GC)

Heap 영역과 참조
- 자바에서 객체(`new Object()`)는 Heap 영역에 저장된다.  
- 개발자가 변수를 없애도(`obj = null;`) 그 순간 바로 지워지지 않는다.  
- 대신 GC가 "더 이상 쓰이지 않는 객체"를 찾아서 메모리에서 지운다.  
- 따라서 C처럼 `free(obj);`를 직접 호출할 필요가 없다.  

---

Stop-The-World
- GC가 실행되면 모든 스레드가 멈춘다.  
- 이유: GC가 "살아 있는 객체 vs 죽은 객체"를 판별해야 하는데, 그 시점에도 프로그램이 계속 실행되면 데이터가 꼬일 수 있기 때문이다.  
- 따라서 GC는 프로그램을 잠깐 멈추고 안전하게 작업을 수행한다.  
- 단점: 애플리케이션이 순간적으로 멈추는 지연(Latency)이 발생한다.  

---

## Mark & Sweep (표시하고 쓸어내기)
1. Mark 단계: Heap을 탐색하면서 참조되고 있는 객체에 표시(mark)를 붙인다.  
2. Sweep 단계: 표시가 없는 객체(쓰레기)를 쓸어내서 메모리에서 해제한다.  

- 단점: 해제 후 메모리가 여기저기 흩어져 "조각(fragmentation)"이 생길 수 있다.  
- 해결책: Compaction(압축)으로 살아남은 객체를 한쪽으로 모아 정리한다.  

---

Generational GC (세대별 관리)
- 대부분의 객체는 금방 사라진다. (예: 메서드 안에서 잠깐 쓰이는 변수)
- 그래서 Heap을 Young 영역과 Old 영역으로 나눠 관리한다.

1. Young Generation (Eden + Survivor) 
   - 새로 생성된 객체가 들어가는 영역.  
   - 대부분 금방 사라져서 여기서 바로 청소된다. (Minor GC)  

2. Old Generation
   - Young 영역에서 오래 살아남은 객체가 이동하는 공간.  
   - 여기서 청소가 일어나면 시간이 오래 걸린다. (Major GC)  

- 이 구조 덕분에 "짧게 쓰다 버려지는 객체"와 "오래 살아남는 객체"를 효율적으로 관리할 수 있다.  
```

### 면접 포인트

* JVM 구조 5대 구성 요소 설명 가능?
* GC가 언제 실행되는지? 어떤 상황에서 OOM(Out Of Memory)이 나는지?
* JIT 컴파일러와 인터프리터의 차이?

---

## 2. Java Collections - HashMap vs ConcurrentHashMap

### HashMap (기본기부터 정리)

* **Key-Value 저장소**: `map.put(key, value)` 형식으로 데이터를 저장.
* 내부 구조는 **배열 + 연결리스트(또는 트리)**.
* 데이터를 꺼낼 때는 `hashCode()` → 배열 인덱스 계산 → 같은 인덱스에 여러 개 들어오면 `equals()`로 비교.
* **특징**

  * `null` 키 1개 허용, `null` 값은 여러 개 가능.
  * 멀티스레드 환경에서 안전하지 않음 (여러 스레드가 동시에 수정하면 데이터 꼬임).

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>();
        map.put("id", "1001");
        map.put("name", "상원");
        map.put("job", "Backend Developer");

        System.out.println(map.get("name")); // 상원
    }
}
```

-> HashMap은 **단일 스레드 환경**(예: 간단한 CRUD 앱, 데이터 캐시)에서는 빠르고 효율적이지만, **멀티스레드 환경**에서는 **동기화 문제** 때문에 위험해.

---

### HashMap의 충돌 처리

JDK 8 기준:

* 같은 `hashCode` 값이 나올 경우, **LinkedList**로 연결.
* 충돌이 많아 리스트가 일정 크기 이상 되면 **Red-Black Tree**로 변환 → 탐색 시간 O(n) → O(log n)으로 줄임.

---

### ConcurrentHashMap (멀티스레드 안전한 Map)

* HashMap을 멀티스레드에서 안전하게 쓰기 위해 나온 자료구조.
* 내부적으로 `synchronized`나 `Lock`을 쓰지만, 전체에 거는 게 아니라 **부분 부분만 잠금**을 건다.
* JDK 7까지: **Segment 단위**로 락을 걸어서 동시성 확보.
* JDK 8 이후: **CAS (Compare-And-Swap) 연산 + synchronized 블록**을 사용해 성능을 대폭 향상.

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        Map<String, Integer> cmap = new ConcurrentHashMap<>();
        cmap.put("apple", 10);
        cmap.put("banana", 20);

        // 여러 스레드가 동시에 접근해도 안전함
        cmap.computeIfAbsent("orange", key -> 30);

        System.out.println(cmap);
    }
}
```

**HashMap vs ConcurrentHashMap 비교**

| 특징     | HashMap     | ConcurrentHashMap |
| ------ | ----------- | ----------------- |
| 동기화    | ❌           | ✅ (세밀한 락 / CAS)   |
| null 키 | 1개 허용       | ❌ 불가              |
| null 값 | 여러 개 허용     | ❌ 불가              |
| 성능     | 단일 스레드에서 빠름 | 멀티스레드에서 안전 + 효율   |

---

### 면접 포인트

* "HashMap은 스레드 안전한가요?" → ❌
* "ConcurrentHashMap은 왜 성능이 좋은가요?" → 세밀한 락, CAS 연산 덕분.
* "HashMap에서 key 충돌 나면 어떻게 되나요?" → LinkedList / Tree 구조.

---

## 3️. 오버로딩 vs 오버라이딩

### 오버로딩(Overloading) — **이름 같아도 매개변수 다르면 인정**

* 같은 클래스 안에서 **메서드 이름은 같지만 매개변수 시그니처가 다른 경우**.
* 컴파일러가 **정적 바인딩**으로 호출할 메서드를 미리 결정.

```java
class Printer {
    void print(String msg) {
        System.out.println("문자열 출력: " + msg);
    }

    void print(int number) {
        System.out.println("정수 출력: " + number);
    }

    void print(String msg, int number) {
        System.out.println("조합 출력: " + msg + " - " + number);
    }
}

public class OverloadingExample {
    public static void main(String[] args) {
        Printer p = new Printer();
        p.print("상원");      // 문자열 출력
        p.print(2025);        // 정수 출력
        p.print("나이", 25);  // 조합 출력
    }
}
```

-> 같은 이름이라도 **매개변수 타입/개수**가 다르면 전부 인정해줌.
-> 리턴 타입만 다르고 매개변수가 같으면 X (구분 불가).

---

### 오버라이딩(Overriding) — **부모 걸 덮어쓰기**

* 상속 관계에서 부모의 메서드를 자식이 재정의.
* 호출 시점은 런타임 → **동적 바인딩**.

```java
class Animal {
    void sound() {
        System.out.println("동물이 소리를 낸다");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("야옹!");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();

        a1.sound(); // 멍멍!
        a2.sound(); // 야옹!
    }
}
```

부모 타입으로 선언해도 실제 객체 타입에 따라 실행 결과가 달라짐. (다형성의 핵심!)

---

### 오버로딩 vs 오버라이딩 비교

| 구분    | 오버로딩(Overloading)    | 오버라이딩(Overriding)  |
| ----- | -------------------- | ------------------ |
| 정의    | 같은 이름, 다른 매개변수       | 부모 메서드를 자식이 재정의    |
| 시점    | 컴파일 타임 (정적 바인딩)      | 런타임 (동적 바인딩)       |
| 리턴 타입 | 다르면 ❌ (매개변수까지 달라야 함) | 부모와 동일하거나 하위 타입 가능 |
| 상속 필요 | ❌ 필요 없음              | ✅ 반드시 상속 관계        |

---

### 면접 포인트

* 오버로딩과 오버라이딩의 차이? (컴파일 vs 런타임, 정적 vs 동적)
* `@Override` 애너테이션을 왜 쓰나요? → 실수 방지 + 가독성.
* 다형성은 왜 중요한가요? → 유지보수성, 확장성 증가.





