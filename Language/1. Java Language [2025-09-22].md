# 1. JVM과 GC
## JVM란?

Java Virtual Machine

자바 가상 머신, 자바 프로그램 실행을 위한 프로그램

다른 언어로 작성된 것도 자바 byte code로 컴파일하여 실행

## JVM의 구조

### Class Loader Subsystem

클래스 로더는 생성된 클래스 파일들을 엮어서 JVM이 OS로부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할

클래스 파일들은 Runtime이 될 때 load, links, initialize의 과정을 거침

- **Load(적재)**
    
    클래스 로더가 클래스 파일을 읽어 JVM 메모리에 적재해 준비하는 과정
    
- **Linking(연결)**
    
    로드된 클래스나 인터페이스를 검증하고 준비
    
    컴파일러가 잘 변환 했는지 검증 → JVM에 의한 데이터 구조나 Static 변수를 위한 저장 공간을 위해 메모리 할당 → 심볼릭 참조를 실제 메모리 참조로 변경
    
- **Initialize(초기화)**
    
    클래스나 인터페이스의 초기화 로직 실행
    
    링크 단계에서 초기화된 Static 변수들을 입력한 값으로 정의
    

### Runtime Data Areas

JVM 프로그램이 실행이 될 때 OS로부터 할당받은 메모리의 영역

→ 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역

**모든 스레드가 공유**해서 사용(GC의 대상) : 힙 영역(Heap Area), 메서드 영역(Method Area)

**스레드마다 하나씩** 생성 : 스택 영역(Stack Area), PC 레지스터(PC Register), 네이티브 메서드 스택(Native Method Stack)

- **메서드 영역**
    
    JVM이 시작될 때 생성되는 공간, 바이트 코드를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간
    
    프로그램이 종료될 때까지 저장
    
    클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메서드, 변수) 저장
    
- **힙 영역**
    
    new 키워드로 생성된 객체와 배열이 생성
    
    주기적으로 GC가 제거
    
    - **Young Generation**
        
        새로 생성된 객체가 저장되는 영역
        
        Minor GC가 이 영역을 정리함 → 발생 빈도가 높음
        
        - Eden Space
            
            새로 생성된 객체가 처음 저장되는 공간
            
            가득 차면 Minor GC 발생 → 살아남은 객체는 Survivor로 이동
            
        - Survivor Space
            
            Eden에서 살아남은 객체가 복사되어 들어옴
            
            GC마다 S0 ↔ S1 사이에서 살아남은 객체를 번갈아 이동
            
            일정 횟수 이상 살아남으면 Old Generation으로 승격(Promotion)
            
    - **Old Generation**
        
        여러 번 GC에서 살아남은 수명이 긴 객체가 저장되는 공간
        
        Major GC(Full GC)가 이 영역을 정리함 → 발생 시 애플리케이션 멈춤 시간이 길어질 수 있음
        
    - **Metaspace (Java 8 이후)**
        
        클래스의 메타데이터 저장 공간
        
        Heap이 아니라 **Native 메모리**를 사용
        
        동적으로 크기 조정 가능
        
- **스택 영역**
    
    지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값이 생성되는 영역
    
- **PC 레지스터**
    
    스레드가 생성될 때마다 생성되는 영역으로 프로그램 카운터, 즉 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
    
- **네이티브 메서드 스택**
    
    자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역
    
    자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할
    

### 작동 방식

![image.png](attachment:f7b0ae05-5ba7-44d5-937d-54d20c1b2917:image.png)

1. JVM이 OS로부터 메모리 할당
2. 자바 컴파일러(javac)가 자바 소스코드를 바이트코드(.class)로 컴파일
3. Class Loader를 통해 JVM Runtime Data Area로 로딩
4. Runtime Data Area로 로딩 된 바이트코드들은 Execution Engine을 통해 해석
5. 해석된 바이트 코드는 Runtime Data Area의 각 영역에 배치되에 수행하며 이 과정에서 Execution Engine에 의해 GC의 작동과 스레드 동기화가 이루어짐

## GC(Garbage Collector)란?

더는 사용하지 않는 메모리를 자동으로 회수하는 역할

Heap 메모리 영역에 생성(적재)된 객체들 중에 참조되지 않은 객체들을 탐색 후 제거하는 역할

개발자가 직접 관리하지 않아도 되어서 메모리 누수 문제 줄일 수 있음

언제 실행되는지는 X

Stop-The-World (STW) : GC역할을 수행하는 스레드를 제외한 나머지 모든 스레드들은 일시정지상태

### 역할

- 불필요한 객체 식별
    
    Heap 메모리에 적재된 객체 중에서 참조되지 않는 객체를 탐색
    
- 메모리 회수
    
    식별된 객체를 제거하여 사용 가능한 메모리 확보
    
- 객체 압축
    
    객체를 Heap 한쪽에 몰아서 연속적으로 배치
    

### GC 종류

Serial, Parallel, CMS, G1, ZGC, Shenandoah 등

**Serial**은 단일 스레드로 단순하지만 현대에서는 사용 X

**Parallel**은 처리량 중심, CMS**는** 응답 시간 단축에 초점

**G1**은 Heap을 Region 단위로 관리해 stop-the-world를 줄이고 현재 가장 많이 사용

최근에는 초저지연을 목표로 한 **ZGC**, **Shenandoah**도 있음

# 2. Java Collections (HashMap, ConcurrentHashMap)
# 3. 오버로딩과 오버라이딩
## 오버로딩

같은 이름의 메서드를 여러 개 정의할 수 있도록 하는 기능

이때 메서드 이름과 반환 타입은 같아야 하며, 매개변수의 타입이나 개수는 달라야 함

오버로딩은 컴파일 시점에서 어떤 메서드가 호출될지가 결정됨 → 정적 다형성

## 오버라이딩

상속 관계에서 발생하는 개념으로 자식 클래스가 부모 클래스의 메서드를 재정의

이때 메서드의 이름, 매개변수, 반환 타입이 상위 클래스의 메서드와 동일

오버라이딩은 런타임 시점에서 어떤 메서드가 실행될지가 결정됨 → 동적 다형성

## Q. 오버라이딩할 때 반환 타입을 다르게 줄 수 있나요?

자바 5부터는 예외적으로 **공변 반환 타입**이 허용

부모 클래스 메서드가 반환하는 타입보다 **더 구체적인 하위 타입**으로는 반환 타입을 변경 가능

ex) 부모가 `Number`를 반환한다면, 자식 클래스는 `Integer`와 같이 `Number`의 하위 타입을 반환하도록 오버라이딩할 수 있음

완전히 다른 타입은 불가능하지만 부모 반환 타입의 하위 타입으로는 변경이 가능
