# 3. REST vs gRPC

## 1️⃣ 왜 REST와 gRPC를 비교하는가?

두 기술은 **"분산 시스템에서 서비스들이 어떻게 소통할 것인가?"** 라는 동일한 질문에 대한 서로 다른 시대의 답변입니다.

- **REST (Representational State Transfer):** 웹의 폭발적인 성장과 함께, "사람이 이해하기 쉽고, 어떤 클라이언트든 쉽게 연결할 수 있는 범용적인 소통 방식은 없을까?" 라는 고민에서 탄생
  - HTTP/1.1 프로토콜 위에 '자원(Resource)' 이라는 개념을 중심으로 구축된 **아키텍처 스타일**

- **gRPC (gRPC Remote Procedure Call):** 구글이 수많은 마이크로서비스(MSA)를 운영하며 "서버 간 통신을 어떻게 하면 더 빠르고, 효율적이고, 안정적으로 만들 수 있을까?" 라는 내부적인 필요에 의해 탄생  
  - HTTP/2의 성능을 최대한 활용하고, '함수 호출(Function Call)' 처럼 서비스를 명확하게 정의하는 **RPC 프레임워크**


| 항목 | REST                       | gRPC |
|------|----------------------------|------|
| 철학 | 자원(Resource) 중심의 아키텍처 스타일	 | 서비스(Service) 중심의 원격 함수 호출 |
| 기반 프로토콜 | HTTP/1.1 (웹의 표준)           | HTTP/2 (성능 극대화) |
| 데이터 형식 | JSON (사람이 읽기 쉬운 텍스트)       |	Protocol Buffers (기계가 처리하기 빠른 바이너리) |
| 소통 방식 | 명사(URI)와 동사(Method)의 조합                     | 미리 정의된 함수(메서드) 호출 |	 
		
---

## 2️⃣ gRPC가 REST보다 빠른 핵심 이유 4가지
1. **데이터 형식 (Protobuf vs. JSON):** Protobuf는 스키마(IDL) 기반의 **바이너리 직렬화 방식** 필드 이름 같은 메타데이터 없이 데이터를 압축 전송하므로, 
텍스트 기반인 JSON보다 페이로드(Payload) 크기가 훨씬 작음

2. **프로토콜 (HTTP/2 vs. HTTP/1.1):** gRPC는 HTTP/2를 기반으로 동작합니다. 
   1. **양방향 스트리밍:** 하나의 연결로 여러 요청/응답을 **동시에 처리**
   2. **헤더 압축 (HPACK):** 반복적인 HTTP 헤더 정보를 압축하여 전송 오버헤드를 크게 줄임 
   3. **지속적인 연결:** 한 번 맺은 연결을 계속 재사용하여 매번 **연결을 맺는 비용X**


---

## 4️⃣ 언제, 무엇을 선택해야 하는가? 

| 상황                                                              | 추천 기술 | 그 이유는?                                                                                                                        |
| :---------------------------------------------------------------- | :-------- |:------------------------------------------------------------------------------------------------------------------------------|
| **외부에 공개하는 Public API**<br>(ex: 카카오맵 API, 결제 API)      | **REST** | **압도적인 범용성과 쉬운 디버깅**이 중요합니다. JSON은 사람이 바로 읽을 수 있고, 별도 도구 없이 `curl`이나 브라우저로 쉽게 테스트할 수 있어 외부 개발자들의 채택률을 높임                      |
| **내부 마이크로서비스(MSA) 간 통신**<br>(ex: 주문 서비스 ↔︎ 재고 서비스) | **gRPC** | **ms 단위의 지연 시간(Latency) 감소가 서비스 전체 성능을 좌우**합니다. 엄격한 스키마(Protobuf)를 통해 서비스 간 데이터 계약을 강제하여 안정성을 높이고, 스트리밍 기능으로 복잡한 통신을 효율적으로 처리 |
| **웹 브라우저가 직접 호출하는 API**<br>(ex: SPA 프론트엔드)          | **REST** | 모든 브라우저는 HTTP/1.1과 JSON을 네이티브로 지원하여 **호환성 문제가 없습니다.** gRPC를 사용하려면 `gRPC-Web`이라는 프록시 기술이 추가로 필요하여 구조가 복잡                       |
| **모바일 환경이나 IoT 디바이스 통신** | **gRPC** | 데이터 전송량이 적고 배터리 소모에 민감한 환경에서는 **작은 페이로드와 효율적인 연결 재사용**이 큰 장점                                                                  |
---

## 5️⃣ 면접 예상 질문 (요약 답변)

**Q1. 언제 gRPC를, 언제 REST를 써야 하나요?**  
>  "서비스의 성격과 통신 대상에 따라 결정하겠습니다. **외부 개발자나 웹 브라우저 클라이언트에게 제공하는 Public API**라면 범용성과 문서화, 디버깅 편의성을 고려해 **REST**를 선택하겠습니다. 반면, **내부 마이크로서비스 간의 고성능 통신**이 필요하다면, 지연 시간을 최소화하고 엄격한 API 계약을 강제할 수 있는 **gRPC**를 사용하는 것이 더 효율적입니다. 결국 **성능과 효율성**이 우선이라면 gRPC, **범용성과 호환성**이 중요하다면 REST를 선택하는 것이 올바른 트레이드오프라고 생각합니다."

**Q2. gRPC가 빠른 이유는?**  
> "크게 두 가지 측면에서 설명할 수 있습니다. 첫째, **데이터 포맷**입니다. gRPC는 **Protobuf**를 사용하여 데이터를 바이너리로 직렬화하므로, 텍스트 기반인 JSON보다 페이로드 크기가 훨씬 작습니다. 둘째, **전송 프로토콜**입니다. gRPC는 **HTTP/2** 위에서 동작하여, 하나의 연결로 여러 요청을 동시에 처리하는 **스트림 멀티플렉싱**과 헤더를 압축하는 **HPACK** 기술을 통해 네트워크 오버헤드를 획기적으로 줄입니다. 이 두 가지 조합이 gRPC의 높은 성능을 만들어냅니다."

**Q3. gRPC의 한계는?**  
> 가장 큰 한계는 **브라우저 호환성**입니다. 웹 브라우저는 gRPC를 직접 지원하지 않아 **gRPC-Web**이라는 별도의 프록시를 도입해야 합니다. 또한, 바이너리 프로토콜이라 **디버깅이 어렵습니다.** JSON처럼 요청/응답 내용을 사람이 바로 읽을 수 없어 별도의 디코딩 도구가 필요합니다. 마지막으로, 아직 REST에 비해 생태계나 참고 자료가 상대적으로 부족하다는 점도 실무적인 단점이 될 수 있습니다."
## 🎯 최종 비교 그래프 (At-a-Glance Chart)

| 기준            | REST                                   | gRPC                                     |
| :-------------- | :------------------------------------- | :--------------------------------------- |
| **강점 (Strength)** | ✅ 범용성, ✅ 쉬운 디버깅, ✅ 풍부한 생태계 | ✅ 고성능/저지연, ✅ 엄격한 계약, ✅ 스트리밍 |
| **약점 (Weakness)** | ❌ 높은 오버헤드, ❌ 상대적으로 느림      | ❌ 브라우저 호환성↓, ❌ 어려운 디버깅       |
| **주요 사용처** | **외부 공개 API, 웹/모바일 클라이언트 통신** | **내부 마이크로서비스(MSA) 간 통신** |