##  5. WebSocket

### 1️⃣ WebSocket, 왜 필요한가? (핵심 개념)

**"한마디로 "HTTP의 한계를 극복하기 위해 등장한 진정한 양방향 실시간 통신 기술"** 

- **HTTP의 한계:** 클라이언트가 요청(Request)해야만 서버가 응답(Response)할 수 있는 **단방향 구조**이며, 매번 연결과 해제를 반복하는 **비연결성(Stateless)** 특징을 
  - **실시간 소통에 매우 비효율적**

- **WebSocket의 해결책:**

  - **양방향 통신 (Full-duplex):** 서버와 클라이언트가 서로 원할 때 언제든 데이터를 주고받는 '전화 통화' 방식입니다. 서버가 먼저 클라이언트에게 데이터를 밀어주는 Push가 가능해집니다.

  - **지속적인 연결 (Persistent Connection):** 한번 연결되면 그 통로(TCP)를 계속 유지하며 데이터를 주고받아, 매번 연결을 맺고 끊는 오버헤드가 없습니다.


---

### 2️⃣ Polling / Long-Polling / SSE / WebSocket 비교


| 항목 | Polling | SSE | WebSocket |
|------|----------|-----|-----------|
| 방향성 | 단방향 | 단방향 | **양방향** |
| 지연 | 높음 | 낮음 | **매우 낮음** |
| 데이터 | 텍스트 | 텍스트 | 텍스트/바이너리 |
| 연결 유지 | X | 서버 유지 | **지속 연결** |
| 실시간성 | 낮음 | 중간 | **높음** |

#### 📍 Polling: "혹시 새 소식 있나요?" (주기적인 질문)
- **개념:** 클라이언트가 일정 주기로 서버에 "새 데이터 있나요?"를 요청
- **장점:** 구현 간단, 모든 브라우저/서버 호환
- **단점:** 불필요한 요청 과다, 서버 리소스 낭비, 지연 증가
- **사용 예:** 실시간성 낮은 알림, 단순 데이터 갱신

#### 📍 Long-Polling: "새 소식 생기면 바로 알려주세요." (대기하는 질문)
- **개념:** 서버가 응답을 보류하고, 데이터가 생기면 즉시 응답 → 즉 pseudo push
- **장점:** Polling 대비 지연 감소
- **단점:** 연결 유지 오버헤드, 서버 스레드 리소스 점유
- **사용 예:** 구형 환경(HTTP/1.1)에서의 채팅/알림

#### 📍 SSE (Server-Sent Events): "서버가 보내주는 소식만 들을게요." (서버의 일방적 방송)
- **개념:** 서버에서 클라이언트로 단방향 데이터 스트림을 전송하는 HTML5 표준 기술
- **특징:** 구현이 간단하고, HTTP 기반이라 기존 인프라와 호환성이 좋음
- **장점:** 단방향 푸시에 매우 적합, 가볍고 안정적
- **단점:**오직 서버 → 클라이언트 방향만 가능하며, 텍스트 데이터만 전송할 수 있음
- **사용 예:** 뉴스 피드, 주식 시세, 알림 스트림

#### 📍 WebSocket: "이제 우리 계속 대화해요." (실시간 전화 통화)
- **개념:** HTTP Handshake 후 TCP 위에서 양방향 실시간 통신
- **특징:** 매우 낮은 지연 시간, 최소한의 데이터 전송량, 텍스트와 바이너리 모두 지원하여 압도적인 실시간 성능을 보장
- **장점:** 저지연, 지속 연결, 양방향 통신, 효율적 대역폭 사용
- **단점:** 상태를 유지(Stateful)해야 하므로 서버 구현 및 확장(Scale-out) 전략이 복잡
- **사용 예:** 채팅, 주식 거래, 게임, IoT 제어, 실시간 대시보드


### 3️⃣ 장점과 단점 (Pros & Cons)

#### ✅ 장점 (Benefits)
* **압도적인 실시간성**: 매우 낮은 지연 시간(Low Latency)으로 즉각적인 데이터 교환이 가능합
* **효율적인 대역폭**: 최초 연결 후에는 작은 크기의 프레임만 교환하므로 HTTP 헤더 오버헤드가 없음.
* **유연한 데이터 교환**: 텍스트(JSON 등)와 바이너리(이미지, 오디오 등) 데이터를 모두 지원
* **양방향 통신**: 클라이언트와 서버가 동등한 위치에서 데이터를 주고받음

#### ⚠️ 단점 (Challenges)
* **상태 유지(Stateful) 관리의 복잡성**: 서버가 각 클라이언트의 연결 상태를 계속 관리해야 하므로 메모리 등 서버 자원 부담
* **서버 확장(Scale-out)의 어려움**: 여러 서버로 확장할 때 특정 클라이언트는 **항상 동일한 서버에 연결되도록 보장(Sticky Session)** 해야 하는 등 로드 밸런싱 전략이 복잡
* **방화벽 및 프록시 호환성**: 일부 오래된 방화벽이나 프록시 서버는 WebSocket 프로토콜을 이해하지 못해 연결을 차단할 수 있음
* **디버깅의 어려움**: 표준 브라우저 툴 외에 트래픽을 분석하기가 HTTP보다 까다로움


---

### 4️⃣ 실무 활용 사례

- **실시간 채팅 / 협업**
- **주식·암호화폐 호가 스트림**
- **멀티플레이어 게임 상태 동기화**
- **IoT 디바이스 제어**

---

### 5️⃣ 면접 예상 질문 (핵심 답변)

**Q1. Polling 대신 WebSocket을 사용하는 이유는 무엇인가요?**

> "가장 큰 이유는 '효율성' 때문입니다. Polling은 클라이언트가 계속 불필요한 요청을 보내 서버 자원을 낭비하지만, WebSocket은 한번 연결 후 필요한 데이터만 주고받는 지속성 연결 방식이라 압도적으로 효율적이고 실시간성이 높습니다."

**Q2. WebSocket Handshake 과정을 설명**

> "기존 HTTP를 통해 연결을 시작합니다. 클라이언트가 HTTP 헤더에 **Upgrade: websocket**을 담아 요청하면, 서버가 이를 수락하고 **상태 코드 101 Switching Protocols**로 응답합니다. 이후 통신 채널이 WebSocket 프로토콜로 전환되어 양방향 통신이 시작됩니다."

**Q3. WebSocket 서버를 여러 대로 확장(Scale-out)할 때의 고려사항은 무엇인가요?**

> "WebSocket은 **상태를 유지(Stateful)**하므로 단순 로드밸런싱이 어렵습니다. 해결책으로, 특정 사용자를 항상 같은 서버로 보내는 '스티키 세션' 방식이나, 서버 간 메시지를 중계해주는 'Redis Pub/Sub' 같은 메시지 브로커를 도입하여 상태를 동기화하는 방식을 사용해야 합니다."

**Q4. WebSocket의 보안을 강화하는 방법은 무엇인가요?**

> "세 가지가 핵심입니다. 첫째, wss:// 프로토콜을 사용해 통신을 암호화합니다. 둘째, Handshake 단계에서 Origin 헤더를 검증하여 허가된 출처의 요청만 수락합니다. 셋째, 연결 시 JWT 같은 토큰으로 사용자를 인증하여 인가된 사용자만 통신하도록 제한합니다."

---

### 🎯 최종 요약: 어떤 기술을 선택할 것인가?

| 기술 | 핵심 특징 | 이럴 때 사용하세요! |
| :--- | :--- | :--- |
| **WebSocket** | ✅ 양방향, ✅ 초저지연, ✅ 바이너리 지원 | 💬 **실시간 채팅, 멀티플레이어 게임, 협업 툴** |
| **SSE** | ✅ 서버→클라이언트 단방향, ✅ 자동 재연결, ✅ HTTP 친화적 | 📰 **뉴스 피드, 주식 시세, 대시보드 업데이트** |
| **Long Polling** | ✅ 의사(Pseudo) 푸시, ✅ 높은 호환성 | 낡은 시스템 환경에서 실시간 흉내 낼 때 |
| **Polling** | ✅ 가장 단순함 | 실시간이 전혀 중요하지 않을 때 |



