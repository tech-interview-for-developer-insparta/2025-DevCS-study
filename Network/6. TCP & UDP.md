## TCP (Transmission Control Protocol)

### 연결 지향형 프로토콜

- **연결 설정 필요**: 데이터 전송 전 3-way handshake로 연결 수립
- **연결 유지**: 통신 중 연결 상태를 지속적으로 관리
- **연결 종료**: 4-way handshake로 안전하게 연결 해제

### 주요 특징

- **신뢰성 보장** : 데이터 전송 순서 보장, 손실 시 재사용
- **흐름 제어 & 혼잡 제어** : 네트워크 상황에 따라 전송 속도 조절
- **속도** : 상대적으로 느림 (오버헤드 존재)
- **오류 검출 및 수정**
    - 체크섬을 통한 데이터 무결성 검증
    - 오류 발생 시 재전송 요청
- **사용 예시** :  HTTP/HTTPS, 이메일(SMTP), 파일 전송(FTP), 원격 접속(SSH, Telnet)

---

## UDP (User Datagram Protocol)

### 비연결형 프로토콜

- **연결 설정 불필요**: 즉시 데이터 전송 가능
- **독립적 패킷 전송**: 각 패킷이 독립적으로 처리됨
- **상태 관리 없음**: 연결 상태 정보를 유지하지 않음

### 주요 특징

- **빠른 전송 속도** : 연결 설정 없이 바로 데이터 전송
    - 연결 설정 과정 없음
    - 최소한의 프로토콜 오버헤드
    - 헤더 크기 작음 (8바이트 고정)
- **신뢰성 없음** : 데이터 손실, 순서 보장 안됨
- **제어 기능 없음** : 흐름/혼잡 제어 없음
- **속도** : 빠름 (오버헤드 없음)
- **브로드캐스트/멀티캐스트 지원**
    - 1:N 통신 가능
    - 동시에 여러 수신자에게 전송
- **사용 예시** : 실시간 스트리밍, 온라인 게임, DNS, VoIP

---

### TCP vs UDP 선택 기준

| 기준 | TCP 선택 | UDP 선택 |
| --- | --- | --- |
| 데이터 정확성 | 필수 | 중요하지 않음 |
| 전송 속도 | 상관없음 | 매우 중요 |
| 순서 보장 | 필요 | 불필요 |
| 실시간성 | 불필요 | 필수 |
| 네트워크 상태 | 불안정 | 안정적 |

👉 TCP는 신뢰성(정확성)이 중요할 때, UDP는 속도가 중요할 때 사용

---

## TCP 제어 메커니즘

### 3-Way Handshake

데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립

<img width="500"  alt="Image" src="https://github.com/user-attachments/assets/a84b8064-e982-46b5-8aeb-2c792b1967c7" />

### 과정

**1단계: SYN (클라이언트 → 서버)**

- 클라이언트가 연결 요청
    - 클라이언트 상태 : **CLOSED → SYN_SENT**
- SYN 플래그를 1로 설정하고 초기 순서 번호(Sequence Number) 전송

**2단계: SYN-ACK (서버 → 클라이언트)**

- 서버가 요청을 수락
    - 서버 상태 : **LISTEN → SYN_RECEIVED**
- SYN + ACK 플래그를 1로 설정
- 서버의 초기 순서 번호 전송 + 클라이언트 순서 번호에 1을 더한 값(ACK) 전송

**3단계: ACK (클라이언트 → 서버)**

- 클라이언트가 최종 확인
    - 클라이언트 상태 : **SYN_SENT → ESTABLISHED**
    - 서버 상태 : **SYN_RECEIVED → ESTABLISHED**
- ACK 플래그를 1로 설정하고 서버 순서 번호에 1을 더한 값 전송
- 이후 연결 성립, 데이터 전송 시작

### 목적

- **양방향 통신 확인**: 송수신 능력 검증
- **초기 순서 번호 동기화**: 데이터 순서 관리 준비
- **리소스 할당**: 버퍼 및 연결 상태 정보 할당
- **보안**: SYN Flooding 공격 방지를 위한 메커니즘 제공

### 실패 시나리오

- **SYN 손실**: 클라이언트가 재전송 (보통 3초 후)
- **SYN-ACK 손실**: 서버가 재전송
- **ACK 손실**: 서버가 타임아웃 후 연결 종료

### 4-Way Handshake (연결 종료)

세션을 종료하기 위해 수행되는 절차

<img width="600"  alt="Image" src="https://github.com/user-attachments/assets/3458d74c-e284-41e2-9700-288dec145d5f" />

### 과정

**1단계: FIN (클라이언트 → 서버)**

- 클라이언트가 연결 해제 요청
    - 클라이언트 상태 : **ESTABLISHED → FIN_WAIT_1**
- FIN 플래그 전송

**2단계: ACK (서버 → 클라이언트)**

- 서버가 요청을 확인
    - 서버 상태 : **ESTABLISHED → CLOSE_WAIT**
    - 클라이언트 상태 : **FIN_WAIT_1 → FIN_WAIT_2**
- ACK 전송 (아직 서버는 데이터 전송 가능)

**3단계: FIN (서버 → 클라이언트)**

- 서버가 요청을 수락
    - 서버 상태: **CLOSE_WAIT → LAST_ACK**
    - 클라이언트 상태: **FIN_WAIT_2 → TIME_WAIT**

**4단계: ACK (클라이언트 → 서버)**

- 클라이언트가 최종 확인
    - 서버 상태: LAST_ACK → CLOSED
    - 클라이언트 상태: TIME_WAIT → CLOSED (일정 시간 후)

### TIME_WAIT 상태

- **대기 시간**: 보통 2 × MSL (Maximum Segment Lifetime, 약 30초~2분)
- **목적**:
    - 마지막 ACK가 손실될 경우 재전송 대응
    - 지연된 패킷이 새 연결과 섞이는 것 방지
    - 이전 연결의 모든 패킷이 네트워크에서 소멸되도록 보장

### Half-Close

- 한쪽만 FIN을 보내 송신만 종료하고 수신은 유지 가능
- 서버가 남은 데이터를 계속 보낼 수 있음

## 면접 대비 핵심 포인트

**Q: TCP와 UDP의 가장 큰 차이는?**<br>
A: TCP는 연결 지향적이고 신뢰성을 보장하지만 느리고, UDP는 비연결형으로 빠르지만 신뢰성이 없습니다.

**Q: 3-way handshake가 왜 3단계인가요?**<br>
A: 양방향 통신을 확인하고 초기 순서 번호를 동기화하기 위해서입니다. 2단계로는 클라이언트의 수신 능력을 확인할 수 없고, 1단계 더 추가하는 것은 불필요합니다.

**Q: TIME_WAIT이 왜 필요한가요?**<br>
A: 마지막 ACK의 손실에 대비하고, 지연된 패킷이 새 연결과 섞이는 것을 방지하기 위해서입니다.
