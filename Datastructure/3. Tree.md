# 트리(Tree)

## 1. 개념

* 트리(Tree)는 **계층적(hierarchical) 구조**를 표현하는 자료구조.
* `노드(Node)`와 `간선(Edge)`으로 구성되며, 사이클(순환)이 없는 그래프의 한 종류라고 보면 됨.
* 루트(Root)에서 시작해서 **자식(Child)** 노드로 뻗어나가는 구조.

---

## 2. 용어 정리

* **루트(Root)**: 트리의 가장 위에 있는 시작 노드
* **부모(Parent) 자식(Child)**: 상위-하위 관계
* **형제(Sibling)**: 같은 부모를 가진 노드들
* **리프(Leaf)**: 자식이 없는 노드 (말단 노드)
* **레벨(Level)**: 루트로부터 얼마나 깊은지 (깊이)
* **서브트리(Subtree)**: 특정 노드를 루트로 하는 작은 트리

---

## 3. 이진 트리 (Binary Tree)

* 각 노드가 최대 2개의 자식 노드(Left, Right)를 가질 수 있는 트리
* 트리 중에서 가장 많이 쓰이는 형태

### 종류

* **포화 이진 트리(Full Binary Tree)**: 모든 노드가 0개 또는 2개의 자식을 가짐
* **완전 이진 트리(Complete Binary Tree)**: 마지막 레벨을 제외하고 꽉 차 있고, 마지막 레벨도 왼쪽부터 채워져 있음 → 힙(Heap)이 이 구조 사용
* **편향 이진 트리(Skewed Binary Tree)**: 모든 노드가 한쪽(왼쪽 or 오른쪽)으로만 자식을 가짐

---

## 4. 이진 탐색 트리 (Binary Search Tree, BST)

* **이진 트리의 특별한 형태**
* 규칙:

  1. 왼쪽 서브트리에는 **루트보다 작은 값**이 들어감
  2. 오른쪽 서브트리에는 **루트보다 큰 값**이 들어감
  3. 모든 서브트리도 위 규칙을 따라야 함

### 예시

```
        (8)
       /   \
     (3)   (10)
    /   \      \
  (1)   (6)    (14)
       /   \   /
     (4)   (7)(13)
```

* **탐색(Search)**: 루트에서 시작해서 값 비교 → 왼쪽/오른쪽으로 이동 → 평균 O(log N)
* **삽입(Insert)**: 탐색 규칙 따라 들어갈 자리 찾아 삽입
* **삭제(Delete)**: 세 가지 경우 존재

  1. 리프 노드 삭제 (그냥 제거)
  2. 자식이 하나 있는 노드 삭제 (자식과 연결)
  3. 자식이 둘 있는 노드 삭제 (오른쪽 서브트리 최소값 or 왼쪽 서브트리 최대값으로 교체)

---

## 5. 활용 예시

* **탐색/검색 구조** (DB 인덱스, 파일 시스템)
* **정렬 데이터 관리**
* **힙(Heap), Red-Black Tree, AVL Tree** 같은 고급 트리의 기반

---

## 6. 배열/연결리스트 vs 트리

| 구분    | 배열/연결리스트            | 트리(Tree)           |
| ----- | ------------------- | ------------------ |
| 탐색    | O(n) (순차 탐색)        | O(log n) (BST 기준)  |
| 삽입/삭제 | 배열: O(n), 리스트: O(1) | 평균 O(log n)        |
| 정렬 유지 | 직접 정렬 필요            | 트리 구조 자체가 정렬 상태 유지 |

---

정리하면:

* 트리 = 계층 구조 표현
* 이진 트리 = 자식 최대 2개
* BST = 정렬된 상태로 탐색 빠르게 가능

---

# 힙(Heap) & 레드-블랙 트리(Red-Black Tree)

## 1. 힙(Heap)

### 개념

* **완전 이진 트리(Complete Binary Tree)** 기반의 자료구조
* **우선순위 큐(Priority Queue)** 구현에 많이 사용됨
* 부모 노드와 자식 노드 간에 **대소 관계**가 항상 유지됨

### 종류

* **최대 힙(Max Heap)**

  * 부모 ≥ 자식
  * 루트(최상단)가 가장 큰 값
* **최소 힙(Min Heap)**

  * 부모 ≤ 자식
  * 루트가 가장 작은 값

### 시간 복잡도

* 삽입: O(log n)
* 삭제(루트 제거): O(log n)
* 최댓값/최솟값 조회: O(1)

### 활용 예시

* 우선순위 큐
* 다익스트라(Dijkstra) 알고리즘 (최단 경로)
* 작업 스케줄링

---

## 2. 레드-블랙 트리 (Red-Black Tree)

### 개념

* **자가 균형 이진 탐색 트리(Self-Balancing BST)**
* 삽입/삭제가 일어나도 트리 높이를 \*\*O(log n)\*\*으로 유지
* 규칙을 통해 노드의 색을 바꿔서 균형 맞춤

### 규칙 (5가지)

1. 각 노드는 **빨강(Red)** 또는 \*\*검정(Black)\*\*이다.
2. 루트는 항상 **검정**이다.
3. 모든 리프(NIL)는 **검정**이다.
4. 빨강 노드의 자식은 항상 **검정**이다. (빨강이 연속 X)
5. 어떤 노드에서 시작해서 리프까지 가는 모든 경로에는 **검정 노드 수가 같다.**

### 시간 복잡도

* 탐색, 삽입, 삭제 모두 O(log n)
* 균형 유지 과정에서 **재색칠(Recoloring)**, **회전(Rotation)** 발생

### 활용 예시

* Java `TreeMap`, `TreeSet` 구현체
* Linux 커널 프로세스 스케줄링
* DB 인덱스 (B-Tree/B+Tree와 더불어 많이 사용)

---

## 3. BST vs Heap vs Red-Black Tree 비교

| 구분    | 이진 탐색 트리(BST)        | 힙(Heap)               | 레드-블랙 트리(RBT)         |
| ----- | -------------------- | --------------------- | --------------------- |
| 구조    | 이진 탐색 규칙 (왼<루트<오른)   | 완전 이진 트리              | 균형 이진 탐색 트리           |
| 정렬    | 중위순회 = 정렬된 결과        | 정렬 보장 X (루트만 최댓값/최솟값) | 정렬 유지                 |
| 삽입/삭제 | 평균 O(log n), 최악 O(n) | O(log n)              | O(log n) (균형 유지)      |
| 탐색    | 평균 O(log n), 최악 O(n) | O(n)                  | O(log n)              |
| 활용    | 검색/정렬                | 우선순위 큐                | 안정적 검색/정렬 (언어/DB 구현체) |

---

정리하면:

* **힙**은 우선순위 큐 같은 “최댓값/최솟값” 빨리 뽑는 데 최적화
* **레드-블랙 트리**는 삽입/삭제가 많아도 **항상 균형 유지 → 빠른 탐색** 보장

---

# 그래프(Graph)

## 1. 개념

* \*\*정점(Vertex, Node)\*\*과 \*\*간선(Edge)\*\*으로 이루어진 자료구조
* 트리(Tree)보다 더 일반적인 구조 (트리는 그래프의 일종)
* 현실 세계의 관계망(예: SNS 친구 관계, 도로망, 네트워크)을 표현할 때 사용

---

## 2. 용어

* **정점(Vertex)**: 그래프의 기본 단위 (예: 사람, 도시)
* **간선(Edge)**: 정점과 정점을 연결 (예: 친구 관계, 도로)
* **차수(Degree)**: 한 정점에 연결된 간선 개수
* **경로(Path)**: 한 정점에서 다른 정점까지 이어지는 길
* **사이클(Cycle)**: 시작점과 끝점이 같은 경로

---

## 3. 그래프 종류

1. **방향 그래프(Directed Graph)**

   * 간선에 방향이 있음 → A→B와 B→A는 다름
2. **무방향 그래프(Undirected Graph)**

   * 간선에 방향 없음 → A—B는 B—A와 같음
3. **가중치 그래프(Weighted Graph)**

   * 간선마다 비용/가중치(Weight)가 있음 → 최단 경로 문제에서 중요
4. **비가중치 그래프(Unweighted Graph)**

   * 간선에 가중치가 없는 단순 연결 구조
5. **연결 그래프(Connected Graph)**

   * 모든 정점이 연결되어 있음
6. **비연결 그래프(Disconnected Graph)**

   * 일부 정점이 고립됨

---

## 4. 그래프 표현 방식

1. **인접 행렬(Adjacency Matrix)**

   * 2차원 배열 사용 (O(V²))
   * 구현 단순, 정점 수 적고 간선이 많을 때 유리

   ```
   A—B
   A—C   →   행렬로 표현
   B—C
   ```

2. **인접 리스트(Adjacency List)**

   * 각 정점마다 연결된 노드 리스트 저장 (O(V+E))
   * 메모리 효율적, 간선 적을 때 유리

---

## 5. 탐색 방법

* **DFS (깊이 우선 탐색, Depth-First Search)**

  * 한 경로로 끝까지 파고든 뒤, 막히면 뒤로 돌아와 탐색
  * 재귀나 스택으로 구현
* **BFS (너비 우선 탐색, Breadth-First Search)**

  * 시작점에서 가까운 정점부터 탐색
  * 큐(Queue)로 구현

---

## 6. 활용 예시

* 네트워크 연결 확인 (DFS/BFS)
* 최단 경로 탐색 (Dijkstra, Bellman-Ford, Floyd-Warshall)
* 최소 신장 트리 (Kruskal, Prim)
* 위상 정렬 (작업 순서 결정)
* 소셜 네트워크 분석, 추천 시스템

---

## 7. 트리 vs 그래프

| 구분   | 트리(Tree)        | 그래프(Graph)        |
| ---- | --------------- | ----------------- |
| 구조   | 계층 구조           | 일반적 연결 구조         |
| 간선 수 | 정점-1            | 자유로움              |
| 사이클  | 없음              | 있을 수 있음           |
| 활용   | 계층적 데이터 (파일시스템) | 관계 데이터 (네트워크, 지도) |



